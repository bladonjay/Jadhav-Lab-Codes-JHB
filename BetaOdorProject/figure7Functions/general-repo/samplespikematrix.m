function spkmat = samplespikematrix(samples, unitstruct, after)
% Call this function with the first argument is the 'samples' output from
% either andreaevents, or multipdayevents.
% spkmat = samplespikematrix(samples, unitdataday1, unitdataday2, ...)
% varargin= unitdata, with field units. this should be only one struct
% Generated by sam Mackenzie, fixed by JH Bladon

% this is the max seconds you allow for the sampling epoch %%% check this
%%%%%%%%%%%%%%%%
if ~exist('after','var')
    after=2;
elseif isempty(after)
    after=2;
end
%%%%%%%%%%%%%%%%
nunits = 0;
spkmat = nan(size(samples,1),0);
% for each day of trials
for d = 1:length(unitstruct)
    % e.g. concatenate each sampling event
    daysamples = samples(samples(:,10)==d,:);
    
    dayunitdata = unitstruct(d);
    if isfield(dayunitdata,'units')
        ndayunits = numel(dayunitdata.units);
    else
        ndayunits = numel(dayunitdata.neurons);
    end
    dayspkmat = nan(size(daysamples,1),ndayunits);
    % for each unit in that day:
    for n = 1:ndayunits;
        % spk is the spike timestamps of that unit
        if isfield(dayunitdata,'units')
            spk = dayunitdata.units(n).ts(:);
        else
            spk = dayunitdata.neurons{n}.timestamps(:);
        end
        % 9th col- any sample that is longer than the after (1.5 secs) is
        % maxxed at 2 secs
        daysamples(daysamples(:,9)>after,9) = after;
        
        for s = 1:size(daysamples,1)
            if all(~isnan(daysamples(:,9)))
                % heres where the function is performed- find the spikes
                % after this sample but before the end, / the duration for
                % each spike
                thissample = (spk(:,1)>=daysamples(s,1) & spk(:,1)<daysamples(s,1)+daysamples(s,9))/daysamples(s,9);
            else
                thissample = (spk(:,1)>=daysamples(s,1) & spk(:,1)<daysamples(s,1)+after)/(after);
            end
            % returns a list of spikes, each spike is already divided by
            % the sample interval... he does this backwards, instead of
            % summing all the spikes up and then dividing by time, he
            % divides by time and then sums... 
            nspks = sum(thissample); % Count the Number of SPiKeS (theyre already divided by time)
            dayspkmat(s,n) = nspks; % Store the rate of spikes in the spike matrix.
        end
    end
    if(nunits < ndayunits)
        nunits = ndayunits;
        spkmat(:,end+1:nunits) = 0;
    end
    spkmat(samples(:,10)==d,1:ndayunits) = dayspkmat;
end
